# 第九周 网络编程

## socket 粘包问题及解决办法

### 什么是粘包问题？

TCP 本质上只是一个传输控制协议（Transmission Control Protocol，TCP），它是一种面向连接的、可靠的、基于字节流的传输层通信协议。

在 TCP 的交互中，数据是以字节流的形式进行传输的，而“流”的传输是没有边界的，因为没有边界所以就不能区分消息的归属，从而就会产生粘包和半包问题。

所以说，粘包问题是指，在接收到数据的时候，收到的数据不属于一个完整的业务消息，而是包含了多个业务消息的内容。

### 引起粘包问题的原因？

1. 发送方发送数据的大小（size）小于 socket 的缓冲区大小（size）
2. 接收方没有及时接收和处理 socket 中的数据

### 如何解决粘包问题？

常用的解决方法有三种，分别为：

#### fix length 固定长度消息

这个解决方案的思路是约定一个固定的消息长度，所有的消息都是一个长度，接收方直接按照这个固定长度来解析即可。

如果要发送的数据 < 约定的消息长度，发送方需要对数据进行补齐（比如用 0 值补齐）；

如果要发送的数据 > 约定的消息长度，发送方需要将数据进行截断（分包分片），接收方也需要做组装（将分包分片的数据组装成一个完整的业务消息）

这个解决方案的缺点很明显。主要有两个：

1. 浪费，对于小 size 的消息需要补齐长度，最终导致发送到网络的数据大于业务实际的消息大小

2. 实现复杂。对于大 size 的消息，接收方和发送方都需要处理分包分片的逻辑

#### delimiter based 基于分隔符的方案
    
这个方案的思路是在每一条业务消息的结尾添加一个特殊的分隔符，用于分割不同的消息。

这个方案的优点是：

1. 简单，发送方和接收方都很容易能实现

2. 相较于 fix length 方案，大大减少了浪费

这个方案的缺点是：

1. 业务消息中不能包含被选为分隔符的字符，否则会导致消息解析不正确。常用的做法是将消息体中的特殊字符做转义处理

#### length field based frame decoder

这个方案的思路是实现自定义的消息协议，约定一个固定长度、固定位置的字段来标识消息体的大小。

常见的实现有 HTTP 的 Content-Length；各种 rpc 使用的协议。

一般来说，rpc 的协议包含两个部分： 消息头和消息体。

##### 消息头 header

消息头一般包含如下几个部分（从前往后的顺序排列）

1. magic_number，4 字节，每个自定义协议会有一个自己的 magic_number，用于识别是不是自己的自定义消息

2. version，2 字节，协议版本

3. header_length，4 字节，消息头的 size

4. body_length(或者叫 payload_length)，4 字节，消息体的 size

5. 其他业务元数据，比如序列化协议、压缩方式等等...

这个方案的优点是：

1. 扩展性好，可以很方便的扩展 header 中的字段，并且能够使用各种序列化方式序列化消息体（只需要在 header 中指明即可）

2. 有利于工程化，比如可以利用 header 中的元数据做多环境路由（env 字段）；用于链路追踪（trace_id）

这个方案的缺点：

1. 相对于分隔符的方案，发送的数据 size 较大




